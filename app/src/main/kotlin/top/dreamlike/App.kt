/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package top.dreamlike

import io.vertx.core.AbstractVerticle
import io.vertx.core.Vertx
import io.vertx.core.buffer.Buffer
import io.vertx.core.http.HttpMethod
import io.vertx.core.http.HttpMethod.*
import io.vertx.core.json.Json
import io.vertx.core.streams.ReadStream
import io.vertx.ext.web.Route
import io.vertx.ext.web.Router
import io.vertx.ext.web.RoutingContext
import io.vertx.kotlin.coroutines.await
import io.vertx.kotlin.coroutines.dispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import top.dreamlike.RouterCoroutineScope.Companion.co_route
import kotlin.coroutines.CoroutineContext


fun main() {
    val vertx = Vertx.vertx()
    vertx.deployVerticle(TestVerticle())
}

class TestVerticle : AbstractVerticle() {
    override fun start() {
        val router = Router.router(vertx)
        router.co_route {
            GET bindPath "/hello" produce "text/plain" bindToHandle {
                delay(1000)
                "hello world"
            }
        }
        vertx.createHttpServer()
            .requestHandler(router)
            .listen(8080)

    }
}


class RouterCoroutineScope(val router: Router) {


    companion object {
        fun Router.co_route(functions: RouterCoroutineScope.() -> Unit) {
            functions(RouterCoroutineScope(this))
        }
    }

    class RouteContext<B>(val route: Route)

    infix fun HttpMethod.bindPath(path: String?) = when {
        this == GET -> path?.let { router.get(it) } ?: router.get()
        this == PUT -> path?.let { router.put(it) } ?: router.put()
        this == DELETE -> path?.let { router.delete(it) } ?: router.delete()
        this == POST -> path?.let { router.post(it) } ?: router.post()
        else -> throw UnsupportedOperationException()
    }

    infix fun Route.consume(contentType: String?) = contentType?.let { this.consumes(it) } ?: this

    infix fun Route.produce(contentType: String) = this.produces(contentType)

    infix fun <T> Route.bindToHandle(handle: suspend (RoutingContext) -> T) = co_handle_result(handle)

    infix fun Route.bindToFlowHandle(handle: suspend (RoutingContext) -> ReadStream<Buffer>) = co_handle_flow(handle)

    infix fun Route.bindTo(handle: suspend (RoutingContext) -> Unit) = co_handle_void(handle)

    private fun Route.co_handle_flow(handle: suspend (RoutingContext) -> ReadStream<Buffer>) {
        handler {
            CoroutineScope(it.vertx().dispatcher() as CoroutineContext)
                .launch {
                    try {
                        val stream = handle(it)
                        stream.pipeTo(it.response()).await()
                        it.response().end()
                    } catch (e: Exception) {
                        it.fail(e)
                    }
                }
        }
    }


    private fun <T> Route.co_handle_result(handle: suspend (RoutingContext) -> T) {
        handler {
            CoroutineScope(it.vertx().dispatcher() as CoroutineContext)
                .launch {
                    try {
                        val res = handle(it)
                        it.response().end(Json.encodeToBuffer(res))
                    } catch (e: Exception) {
                        it.fail(e)
                    }
                }
        }
    }


    private fun Route.co_handle_void(handle: suspend (RoutingContext) -> Unit) {
        handler {
            CoroutineScope(it.vertx().dispatcher() as CoroutineContext)
                .launch {
                    try {
                        handle(it)
                    } catch (e: Exception) {
                        it.fail(e)
                    }
                }
        }
    }


}
